<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jehee Cheon</title>
    <description>Blog&lt;/br&gt;공부하고나서 끄적이는 곳</description>
    <link>https://jeheecheon.github.io/</link>
    <atom:link href="https://jeheecheon.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 03 May 2021 17:06:25 +0000</pubDate>
    <lastBuildDate>Mon, 03 May 2021 17:06:25 +0000</lastBuildDate>
    <generator>Jekyll v3.9.1</generator>
    
      <item>
        <title>OpenGL memo</title>
        <description>&lt;p&gt;&lt;img class=&quot;mid-img&quot; src=&quot;/assets/img/post/memo/OpenGL/2021-05-03/Screenshot%202021-05-03%20001642.png&quot; /&gt;
&lt;img class=&quot;mid-img&quot; src=&quot;/assets/img/post/memo/OpenGL/2021-05-03/Screenshot%202021-05-03%20003257.png&quot; /&gt;
&lt;img class=&quot;mid-img&quot; src=&quot;/assets/img/post/memo/OpenGL/2021-05-03/Screenshot%202021-05-03%20003027.png&quot; /&gt;
&lt;img class=&quot;mid-img&quot; src=&quot;/assets/img/post/memo/OpenGL/2021-05-03/Screenshot%202021-05-03%20003847.png&quot; /&gt;
&lt;a href=&quot;https://learnopengl.com/Getting-started/OpenGL&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 03 May 2021 00:40:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/memo/opengl/2021/05/03/opengl/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/memo/opengl/2021/05/03/opengl/</guid>
        
        <category>OpenGL</category>
        
        
        <category>memo</category>
        
        <category>opengl</category>
        
      </item>
    
      <item>
        <title>I made a snake game</title>
        <description>&lt;p&gt;Last year, I made a game called snake game following youtube video tutorial.&lt;br /&gt;
It was not easy for me from the beginning but it quite helped me with understanding basic sutff about CSS and JS. 
\&lt;/p&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;
    &lt;canvas id=&quot;game_area&quot;&gt;&lt;/canvas&gt;&lt;br /&gt;
    &lt;button class=&quot;btn up&quot;&gt;UP&lt;/button&gt;&lt;br /&gt;
    &lt;button class=&quot;btn left&quot;&gt;LEFT&lt;/button&gt;
    &lt;button class=&quot;btn right&quot;&gt;RIGHT&lt;/button&gt;&lt;br /&gt;
    &lt;button class=&quot;btn down&quot;&gt;DOWN&lt;/button&gt;&lt;br /&gt;
    &lt;button id=&quot;start&quot;&gt;START&lt;/button&gt;&lt;br /&gt;
    &lt;span id=&quot;author&quot;&gt;Made by jeheecheon&lt;/span&gt;&lt;br /&gt;
&lt;/div&gt;

&lt;script&gt;
//////////////////////////////////////////////////
//////////////////////////////////////////////////
var canvas = document.getElementById(&quot;game_area&quot;);
var ctx = canvas.getContext(&quot;2d&quot;);
var startBtn = document.getElementById('start');
var direction = &quot; &quot;;
var bestScore = 0;
var score;
const width = 450;
const height = 350;
const snakeSize = 10;
//////////////////////////////////////////////////
//////////////////////////////////////////////////

(function() {
  upBtn = document.getElementsByClassName(&quot;btn&quot;);
  upBtn[0].onmousedown=upBtn[0].ontouchstart=function() {
    if (direction!=&quot;down&quot;)
      direction=&quot;up&quot;;
  };
  upBtn[1].onmousedown=upBtn[1].ontouchstart=function() {
    if (direction!=&quot;right&quot;)
      direction=&quot;left&quot;;
  };
  upBtn[2].onmousedown=upBtn[2].ontouchstart=function() {
    if (direction!=&quot;left&quot;)
      direction=&quot;right&quot;; 
  };
  upBtn[3].onmousedown=upBtn[3].ontouchstart=function() {
    if (direction!=&quot;up&quot;)
      direction=&quot;down&quot;;
  };
  
  window.onkeydown = function(event) {
    switch (event.keyCode) {
    case 37:  //left arrow key
    case 65:  //a key
      if (direction != &quot;rignt&quot;)
        direction = &quot;left&quot;;
      break;
    case 38:  //up arrow key
    case 87:  //w key
      if (direction != &quot;down&quot;)
        direction = &quot;up&quot;;
      break; 
    case 39:  //right arrow key
    case 68:  //d key
      if (direction != &quot;left&quot;)
        direction = &quot;right&quot;;
      break;
    case 40:  //left arrow key
    case 83:  //s key
      if (direction != &quot;up&quot;)
        direction = &quot;down&quot;;
      break;
    default:
      break;
    }
  }
  window.onload = function() {snakeGame.init();};
  startBtn.addEventListener(&quot;click&quot;, function() {snakeGame.start();});
}());

var snakeGame = (function() {
  var init = function() {
    canvas.width = width;
    canvas.height = height;
    areaClear();
  }
  
  var areaClear = function() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'lightgrey';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = 'black';
    ctx.strokeRect(0, 0, canvas.width, canvas.height);
  }
  
  var start = function() {
    startBtn.disabled = true;
    score = 0;
    direction = &quot;down&quot;;
    mySnake = new makeSnake(3);
    createFood();
    gameInterval = setInterval(updateGame, 100);
  }
  
  var stop = function() {
    clearInterval(gameInterval);
    bestScore = (score &gt; bestScore) ? score : bestScore;
    startBtn.disabled = false;
  }
  
  var makeSnake = function(tail_length) {
    this.snake = [];
    for (var i = tail_length; i &gt;= 0; i--)
      this.snake.push({x: i, y: 0})
          
    this.newPos = function() {
      posX = this.snake[0].x;
      posY = this.snake[0].y;
      switch (direction) {
      case &quot;left&quot;:
        posX--;
        break;
      case &quot;right&quot;:
        posX++;
        break;
      case &quot;up&quot;:
        posY--;
        break;
      case &quot;down&quot;:
        posY++;
        break;
      default:
        break;
      }
      if (checkCollision(posX, posY, this.snake))
        stop();
      this.snake.unshift({x: posX,y: posY});  
      if (isThereFood(posX, posY)) {
        score++;
        createFood();
      }
      else
        this.snake.pop();
    }

    this.display = function() {
      for (var i = 0; i &lt; this.snake.length; i++)
        draw.snakeBody(this.snake[i].x, this.snake[i].y)
    }
  }
  
  var draw = {
    snakeBody: function(x, y) {
      ctx.fillStyle = 'green';
      ctx.fillRect(x * snakeSize, y * snakeSize, snakeSize, snakeSize);
      ctx.strokeStyle = 'darkgreen';
      ctx.strokeRect(x * snakeSize, y * snakeSize, snakeSize, snakeSize);
    },
    food: function(x, y) {
      ctx.fillStyle='brown';
      ctx.fillRect(x * snakeSize,y * snakeSize, snakeSize, snakeSize);
      ctx.strokeStyle ='black';
      ctx.strokeRect(x * snakeSize, y * snakeSize, snakeSize, snakeSize);
    },
    scoreText: function(x, y, font, color) {
      text = &quot;BEST SCORE: &quot; + bestScore + &quot;   MY SCORE: &quot; + score;
      ctx.font = font;
      ctx.fillStyle = color;
      ctx.fillText(text, x, y);
    }
  }
  
  var checkCollision = function(x, y, arr) {
    if (x &lt; 0 || y &lt; 0 || x &gt;= width/10 || y &gt;= height/10)
      return true;
    for (i = 0; i &lt; arr.length; i++)
      if (x == arr[i].x &amp;&amp; y == arr[i].y) 
        return true;
    return false;
  }
    
  var createFood = function() {
    do {
      foodX=Math.round(Math.random()*(width/10));
      foodY=Math.round(Math.random()*(height/10));
    } while(checkCollision(foodX, foodY, mySnake.snake));
  }
  
  var isThereFood = function(headX, headY) {
    return headX == foodX &amp;&amp; headY == foodY;
  }
  
  var updateGame = function() {
    areaClear();
    mySnake.newPos();
    mySnake.display();
    draw.food(foodX, foodY);
    draw.scoreText(10, height - 10, &quot;15px Georgia&quot;, &quot;black&quot;);
  }
  
  return {init: init, start: start};
}());

&lt;/script&gt;

&lt;style&gt;
      #start {
        background-color: skyblue;
        color: white;
        border: none;
        margin: 20px 0px 0px 0px;
        width: 200px;
        height: 30px;
      }
      #start:hover {
        background-color: orange;
      }
      #start:disabled {
        background-color: grey;
      }
      #author {
        color: lightblue;
        text-shadow: 3px 1px blue;
        font: italic normal bold 30px/30px &quot;Helvetica&quot;;
      }
      #desc {
        font: normal normal bold 20px/20px &quot;Helvetica&quot;;
      }
      #blog {
        font: normal normal bold 15px/15px &quot;Helvetica&quot;;
      }
      .btn {
        background-color:skyblue;
        border:none;
        color:white;
        width:50px;
        height:35px;
        margin:5px 2px 0px 2px;
      }
      .btn:active {
        background-color:blue;
      }
&lt;/style&gt;

</description>
        <pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/daily-life/2021/01/20/daily-life/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/daily-life/2021/01/20/daily-life/</guid>
        
        
        <category>daily-life</category>
        
      </item>
    
      <item>
        <title>DIART#1</title>
        <description>&lt;p&gt;DIARY TEST&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/diary/2020/12/08/diary/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/diary/2020/12/08/diary/</guid>
        
        
        <category>diary</category>
        
      </item>
    
      <item>
        <title>DPI</title>
        <description>&lt;p&gt;Dots per inch (DPI)&lt;br /&gt;
In typography, the size of type is measured in units called points. One point equals 1/72 of an inch.
physical inches are not a useful measure, because there is no fixed relation between physical inches and pixels. Instead, fonts are measured in logical units. A 72-point font is defined to be one logical inch tall. Logical inches are then converted to pixels. or many years, Windows used the following conversion: One logical inch equals 96 pixels.
12 points = 12/72 logical inch = 1/6 logical inch = 96/6 pixels = 16 pixels
This scaling factor is described as 96 dots per inch (DPI).&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;The following illustration shows a 72-point font. The solid lines show a 1” tall bounding box around the text. The dashed line is called the baseline. Most of the characters in a font rest on the baseline. The height of the font includes the portion above the baseline (the ascent) and the portion below the baseline (the descent). In the font shown here, the ascent is 56 points and the descent is 16 points. &lt;br /&gt;
&lt;img src=&quot;https://docs.microsoft.com/en-us/windows/win32/learnwin32/images/graphics11.png&quot; alt=&quot;1 inch&quot; class=&quot;mid-img&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/learnwin32/dpi-and-device-independent-pixels&quot;&gt;출처: Microsoft&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Sep 2020 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/memo/win32/2020/09/17/win32/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/memo/win32/2020/09/17/win32/</guid>
        
        <category>memo</category>
        
        <category>win32</category>
        
        <category>DPI</category>
        
        <category>graphic</category>
        
        
        <category>memo</category>
        
        <category>win32</category>
        
      </item>
    
      <item>
        <title>win32 의 COM Reference Counting</title>
        <description>&lt;p&gt;&lt;br /&gt;
공부하면서 중요한 부분만 발췌했기 때문에 문맥이 매끄럽지 못하고 부정확한 부분이 있음.&lt;br /&gt;
&lt;br /&gt;
COM Interfaces 에 한가지 중요한 규칙이 있는데 이는 IUnknown 이라는 인터페이스를 반드시 상속받는 다는 것이다.&lt;br /&gt;
IUnknown 는 밑에 언급되는 세 가지 Methods를 가지고 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;QueryInterface&lt;/li&gt;
  &lt;li&gt;AddRef&lt;/li&gt;
  &lt;li&gt;Release&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;QueryInterfaec는 프로그램이 객체의 capabilities를 query 할 수 있게 해준다.&lt;br /&gt;
AddRef 와 Release 는 object의 라이프 타임을 결정하게 해주는 중요한 녀석이다.&lt;br /&gt;
&lt;br /&gt;
모든 COM object는 내부 카운트를 유지한다. 이것을 &lt;strong&gt;reference count&lt;/strong&gt;라고 부르고 이는 해당 객체를 참고하는 녀석이 몇 개나 활성화 되어있는가를 보여주는 거를 일겉는다.&lt;br /&gt;
그 숫자가 0에 달했을 시 그 object는 스스로 삭제시킨다. 중요한 부분은 프로그램이 명시적으로 삭제하는 것이 아니라 객체 스스로 없어진다는 것이다.&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;https://docs.microsoft.com/en-us/windows/win32/learnwin32/images/com04.png&quot; alt=&quot;&quot; class=&quot;mid-img&quot; /&gt;&lt;br /&gt;
프로그램이 처음 만들어지면 reference count는 1이 된다.&lt;br /&gt;
그리고 해당 프로그램의 사용을 마친 후 반드시 release를 통해 reference count 를 1감소 시켜야 한다. 이를 통해 
객체의 포인터를 무효화(정지) 를 시킬 수 있다.&lt;br /&gt;
만약 객체의 주소를 다른 포인터 변수에 저장할 일이 있을 때는 AddRef 함수를 통해 reference count를 1 증가시켜줘야만 한다.&lt;br /&gt;
다음 사진과 같이&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;https://docs.microsoft.com/en-us/windows/win32/learnwin32/images/com05.png&quot; alt=&quot;&quot; class=&quot;mid-img&quot; /&gt;&lt;br /&gt;
만약 두 개의 포인터 변수(p,q)가 한 개의 주소를 갖고 있고 AddRef를 하지 않았을 땐 ref count가 1일 것이다. 이때 p가 일을 마치고 release를 하면 값이 0이 되고 q는 무효한 변수로 남게된다. 때문에 변수값을 다른 변수에 저장시 AddRef 호출은 반드시 필요하다.&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
그런데, 객체 주소를 다른 포인터 변수에 저장하는 이유는 무엇일까? 두 가지 이유가 있다.&lt;br /&gt;
첫 번째, structur 나 list 에 저장하기를 원할 때.
두 번째, 포인터 current scope 을 넘어서 사용하고 싶을 때. - [전역변수]&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;전역 후에 오랜만에 win32를 다시 훑는 중인데 확실히 원어로 접하는게 내용수준도 깊고 좋은 것 같다. 다만 읽는데 아직 좀 버거워서 힘들지만 ㅋㅋ 영어 공부도 병행하면서 틈틈히 전공지식도 늘려가는게 좋을 것 같다.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/learnwin32/managing-the-lifetime-of-an-object&quot;&gt;출처: Microsoft&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Sep 2020 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/memo/win32/2020/09/13/win32/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/memo/win32/2020/09/13/win32/</guid>
        
        <category>memo</category>
        
        <category>win32</category>
        
        <category>CPP</category>
        
        <category>COM</category>
        
        
        <category>memo</category>
        
        <category>win32</category>
        
      </item>
    
      <item>
        <title>jekyll 개인 블로그 개설!</title>
        <description>&lt;h1 id=&quot;jekyll-블로그-개설&quot;&gt;&lt;center&gt;jekyll 블로그 개설!&lt;/center&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/post/daily-life/2020-08-29/ant.gif&quot; alt=&quot;춤추는 엔트 사진&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;jekyll(static site generator)&lt;/strong&gt; 을 이용해서 블로그를 새로 만들어 이주했습니다.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/post/daily-life/2020-08-29/blog-code.png&quot; alt=&quot;블로그 코드 스크린샷&quot; width=&quot;100%&quot; /&gt;  &lt;br /&gt;
게시물 주제는 앞으로도 마찬가지로 &lt;strong&gt;프로그래밍 공부 기록&lt;/strong&gt; 및 &lt;strong&gt;정보 공유&lt;/strong&gt; 위주 포스팅이 될 것 같습니다.&lt;br /&gt;
&lt;a href=&quot;https://blog.naver.com/0511cjh&quot;&gt;이주 전 네이버 블로그&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 29 Aug 2020 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/daily-life/2020/08/29/daily-life/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/daily-life/2020/08/29/daily-life/</guid>
        
        <category>jekyll</category>
        
        <category>blog</category>
        
        <category>블로그</category>
        
        <category>개설</category>
        
        
        <category>daily-life</category>
        
      </item>
    
  </channel>
</rss>