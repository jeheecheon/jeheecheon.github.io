<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jehee Cheon</title>
    <description>공부하고나서 끄적이는 곳</description>
    <link>https://jeheecheon.github.io/</link>
    <atom:link href="https://jeheecheon.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 12 May 2021 12:48:07 +0000</pubDate>
    <lastBuildDate>Wed, 12 May 2021 12:48:07 +0000</lastBuildDate>
    <generator>Jekyll v3.9.1</generator>
    
      <item>
        <title>OpenGL에 필요한 수학 공부하기 좋은 사이트</title>
        <description>&lt;p&gt;opengl 공부 중에 삼각함수, 벡터 수식이 쓰일 때가 많은데(대부분…) &lt;br /&gt;
벡터는 아직 커리큘럼상 2학기에 예정되어 있고, 삼각함수는 군대간사이 기억 안나는 부분이 너무 많다.&lt;br /&gt;
그래서 찾은게 이 사이트들인데 정리가 정말 잘 되어있고 시각적으로 보여주는게 많아서&lt;br /&gt;
꽤 쓸만한 것 같다.&lt;br /&gt;
&lt;br /&gt;
당분간 기본적인 것들 다지고 나서 OpenGL 깊게 파봐야겠다…
&lt;br /&gt;
&lt;br /&gt;
아래는 삼각함수 튜토리얼 사이트들 개인적으로 첫번째가 더 낫다(시각자료가 많음)
&lt;a href=&quot;https://www.mathsisfun.com/algebra/trigonometry-index.html&quot;&gt;mathsisfun&lt;/a&gt;
&lt;a href=&quot;https://themathpage.com/aTrig/trigonometry.htm&quot;&gt;themathpage&lt;/a&gt;
&lt;br /&gt;
벡터 tutorial. 시각자료가 많음
&lt;a href=&quot;http://immersivemath.com/ila/index.html&quot;&gt;immersivemath&lt;/a&gt;
&lt;br /&gt;
인도 대학 ccsu- 벡터 tutorial
&lt;a href=&quot;https://chortle.ccsu.edu/vectorlessons/vectorindex.html&quot;&gt;immersivemath&lt;/a&gt;
s&lt;/p&gt;
</description>
        <pubDate>Wed, 12 May 2021 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/notes/math/trigonometry/2021/05/12/daily-life/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/notes/math/trigonometry/2021/05/12/daily-life/</guid>
        
        <category>OpenGL</category>
        
        <category>math</category>
        
        <category>trigonometry</category>
        
        
        <category>notes</category>
        
        <category>math</category>
        
        <category>trigonometry</category>
        
      </item>
    
      <item>
        <title>Transformations</title>
        <description>&lt;p&gt;vector roation 부분은 거의 기억이 나지가 않는다. 기본적인 2D 회전은 이해하겠지만 3D들어가면 힘들 것 같아서 추가로 이부분 공부하고 넘어가야할 것 같다.
&lt;br /&gt;
&lt;img src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-09/Screenshot%202021-05-09%20002920.png&quot; alt=&quot;&quot; /&gt;
&lt;br /&gt;
&lt;a href=&quot;https://learnopengl.com/Getting-started/Transformations&quot;&gt;learnopengl&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 09 May 2021 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/memo/graphics/opengl/2021/05/09/Transformations/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/memo/graphics/opengl/2021/05/09/Transformations/</guid>
        
        <category>OpenGL</category>
        
        <category>Transformations</category>
        
        
        <category>memo</category>
        
        <category>graphics</category>
        
        <category>OpenGL</category>
        
      </item>
    
      <item>
        <title>Coordinate systems</title>
        <description>&lt;p&gt;좌표개념은 익숙하지 않은 내용이라 여러번 읽어봐야 겠다. 
&lt;br /&gt;
&lt;img src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-09-2/Screenshot%202021-05-09%20223226.png&quot; alt=&quot;&quot; /&gt;
&lt;br /&gt;
&lt;a href=&quot;https://learnopengl.com/Getting-started/Coordinate-Systems&quot;&gt;learnopengl&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 09 May 2021 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/notes/graphics/opengl/2021/05/09/Coordinate-Systems/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/notes/graphics/opengl/2021/05/09/Coordinate-Systems/</guid>
        
        <category>OpenGL</category>
        
        <category>Coordinate</category>
        
        <category>Systems</category>
        
        
        <category>notes</category>
        
        <category>graphics</category>
        
        <category>OpenGL</category>
        
      </item>
    
      <item>
        <title>Textures</title>
        <description>&lt;p&gt;이해안되는 내용: 
NEAREST 와 NEAREST 차이는 대충 어떤지 알겠는데 아래 4가지들 차이점은 잘 모르겠다. 나중에 mipmaps 사용할 기회생기면 
직접 모두 출력해보면서 눈으로 확인해봐야 겠다.&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-07-2/Screenshot%202021-05-07%20222523.png&quot; alt=&quot;&quot; /&gt;
&lt;br /&gt;
&lt;a href=&quot;https://learnopengl.com/Getting-started/Textures&quot;&gt;learnopengl&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/notes/graphics/opengl/2021/05/07/Textures/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/notes/graphics/opengl/2021/05/07/Textures/</guid>
        
        <category>OpenGL</category>
        
        <category>Textures</category>
        
        
        <category>notes</category>
        
        <category>graphics</category>
        
        <category>OpenGL</category>
        
      </item>
    
      <item>
        <title>Shaders</title>
        <description>&lt;p&gt;이해안되는 내용: 
꼭지점 3개의 색깔을 정하면 Fragment shader가 알아서 자연스럽게 색깔을 잇는다(?)는 건 
이해했는데, 내부적으로 어떻게 돌아가는지 궁금함.&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-07/Screenshot%202021-05-07%20012048.png&quot; alt=&quot;&quot; /&gt;
&lt;br /&gt;
&lt;a href=&quot;https://learnopengl.com/Getting-started/Shaders&quot;&gt;learnopengl&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/notes/graphics/opengl/2021/05/07/Shaders/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/notes/graphics/opengl/2021/05/07/Shaders/</guid>
        
        <category>OpenGL</category>
        
        
        <category>notes</category>
        
        <category>graphics</category>
        
        <category>OpenGL</category>
        
      </item>
    
      <item>
        <title>Hello triangle</title>
        <description>&lt;p&gt;I din’t know drawing a triangle on screen would be this hard :X&lt;br /&gt;
I haven’t fully understood it yet but I think I’m getting almost there…&lt;br /&gt;
&lt;br /&gt;
그리고 추가로 아직 책에서 설명 안된 부분 때문인지 뭔가 놓친 기분이 든다.&lt;br /&gt;
특히 NDC는 어떻게 사용되는지는 알겠지만 왜 굳이 이 방법을 택했는지 모르겠다.&lt;br /&gt;
그냥 처음부터 screen-space coordinates로 설정해서 사용하지 않는 이유가 너무 궁금하다.&lt;br /&gt;
&lt;img src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-06/Screenshot%202021-05-06%20005930.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-06/Screenshot%202021-05-06%20005515.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;#include &amp;lt;glad/glad.h&amp;gt;
#include &amp;lt;GLFW/glfw3.h&amp;gt;

#include &amp;lt;iostream&amp;gt;

void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow* window);

// settingsR
const unsigned int SCR_WIDTH = 800;
const unsigned int SCR_HEIGHT = 600;

const char* vertexShaderSource = &quot;#version 330 core\n&quot;
&quot;layout (location = 0) in vec3 aPos;\n&quot;
&quot;void main()\n&quot;
&quot;{\n&quot;
&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;
&quot;}\0&quot;;
const char* fragmentShaderSource = &quot;#version 330 core\n&quot;
&quot;out vec4 FragColor;\n&quot;
&quot;void main()\n&quot;
&quot;{\n&quot;
&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;
&quot;}\n\0&quot;;

int main(void) {
    // glfw: initialize and configure
    // ------------------------------
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif

    // glfw window creation
    // --------------------
    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &quot;LearnOpenGL&quot;, NULL, NULL);
    if (window == NULL)
    {
        std::cout &amp;lt;&amp;lt; &quot;Failed to create GLFW window&quot; &amp;lt;&amp;lt; std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);


    // glad: load all OpenGL function pointers
    // ---------------------------------------
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout &amp;lt;&amp;lt; &quot;Failed to initialize GLAD&quot; &amp;lt;&amp;lt; std::endl;
        return -1;
    }

    // glad: load all OpenGL function pointers
    // ---------------------------------------
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout &amp;lt;&amp;lt; &quot;Failed to initialize GLAD&quot; &amp;lt;&amp;lt; std::endl;
        return -1;
    }

    // build and compile our shader program
    // ------------------------------------
    // vertex shader
    unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &amp;amp;vertexShaderSource, NULL);
    glCompileShader(vertexShader);
    // check for shader compile errors
    int success;
    char infoLog[512];
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;amp;success);
    if (!success)
    {
        glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
        std::cout &amp;lt;&amp;lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &amp;lt;&amp;lt; infoLog &amp;lt;&amp;lt; std::endl;
    }
    // fragment shader
    unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &amp;amp;fragmentShaderSource, NULL);
    glCompileShader(fragmentShader);
    // check for shader compile errors
    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;amp;success);
    if (!success)
    {
        glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
        std::cout &amp;lt;&amp;lt; &quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot; &amp;lt;&amp;lt; infoLog &amp;lt;&amp;lt; std::endl;
    }
    // link shaders
    unsigned int shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);
    // check for linking errors
    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;amp;success);
    if (!success) {
        glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
        std::cout &amp;lt;&amp;lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot; &amp;lt;&amp;lt; infoLog &amp;lt;&amp;lt; std::endl;
    }
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    // set up vertex data (and buffer(s)) and configure vertex attributes
    // ------------------------------------------------------------------
    float vertices[] = {
         0.5f,  0.5f, 0.0f,  // top right
         0.5f, -0.5f, 0.0f,  // bottom right
        -0.5f, -0.5f, 0.0f,  // bottom left
        -0.5f,  0.5f, 0.0f   // top left 
    };
    unsigned int indices[] = {  // note that we start from 0!
    0, 1, 3,  // first Triangle
    1, 2, 3   // second Triangle
    };
    unsigned int VBO, VAO, EBO;
    glGenVertexArrays(1, &amp;amp;VAO);
    glGenBuffers(1, &amp;amp;VBO);
    glGenBuffers(1, &amp;amp;EBO);

    // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).
    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    // note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    // You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other
    // VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary.
    glBindVertexArray(0);


    // uncomment this call to draw in wireframe polygons.
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

    // render loop
    // -----------
    while (!glfwWindowShouldClose(window))
    {
        // input
        // -----
        processInput(window);

        // render
        // ------
        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        // draw our first triangle
        glUseProgram(shaderProgram);
        glBindVertexArray(VAO); // seeing as we only have a single VAO there's no need to bind it every time, but we'll do so to keep things a bit more organized
        //glDrawArrays(GL_TRIANGLES, 0, 6);
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
        // glBindVertexArray(0); // no need to unbind it every time 

        // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
        // -------------------------------------------------------------------------------
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    // optional: de-allocate all resources once they've outlived their purpose:
    // ------------------------------------------------------------------------
    glDeleteVertexArrays(1, &amp;amp;VAO);
    glDeleteBuffers(1, &amp;amp;VBO);
    glDeleteProgram(shaderProgram);

    // glfw: terminate, clearing all previously allocated GLFW resources.
    // ------------------------------------------------------------------
    glfwTerminate();

    return 0;
}

// glfw: whenever the window size changed (by OS or user resize) this callback function executes
// ---------------------------------------------------------------------------------------------
void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    glViewport(0, 0, width, height);
}

// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly
// ---------------------------------------------------------------------------------------------------------
void processInput(GLFWwindow* window)
{
    // make sure the viewport matches the new window dimensions; note that width and 
    // height will be significantly larger than specified on retina displays.
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://learnopengl.com/Getting-started/Hello-Triangle&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/notes/graphics/opengl/2021/05/06/Hello-Triangle/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/notes/graphics/opengl/2021/05/06/Hello-Triangle/</guid>
        
        <category>OpenGL</category>
        
        
        <category>notes</category>
        
        <category>graphics</category>
        
        <category>OpenGL</category>
        
      </item>
    
      <item>
        <title>Hello window</title>
        <description>&lt;p&gt;&lt;img class=&quot;mid-img&quot; src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-05/Screenshot%202021-05-05%20001546.png&quot; /&gt;
&lt;img class=&quot;mid-img&quot; src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-05/Screenshot%202021-05-05%20003331.png&quot; /&gt;
&lt;img class=&quot;mid-img&quot; src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-05/Screenshot%202021-05-05%20004558.png&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;#include &amp;lt;glad/glad.h&amp;gt;
#include &amp;lt;GLFW/glfw3.h&amp;gt;

#include &amp;lt;iostream&amp;gt;

void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow* window);

// settings
const unsigned int SCR_WIDTH = 800;
const unsigned int SCR_HEIGHT = 600;

int main(void) {
    // glfw: initialize and configure
    // ------------------------------
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif

    // glfw window creation
    // --------------------
    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &quot;LearnOpenGL&quot;, NULL, NULL);
    if (window == NULL)
    {
        std::cout &amp;lt;&amp;lt; &quot;Failed to create GLFW window&quot; &amp;lt;&amp;lt; std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);


    // glad: load all OpenGL function pointers
    // ---------------------------------------
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout &amp;lt;&amp;lt; &quot;Failed to initialize GLAD&quot; &amp;lt;&amp;lt; std::endl;
        return -1;
    }

    // render loop
    // -----------
    while (!glfwWindowShouldClose(window))
    {
        // input
        // -----
        processInput(window);

        // render
        // ------
        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
        // -------------------------------------------------------------------------------
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    // glfw: terminate, clearing all previously allocated GLFW resources.
    // ------------------------------------------------------------------
    glfwTerminate();

    return 0;
}

// glfw: whenever the window size changed (by OS or user resize) this callback function executes
// ---------------------------------------------------------------------------------------------
void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    glViewport(0, 0, width, height);
}

// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly
// ---------------------------------------------------------------------------------------------------------
void processInput(GLFWwindow* window)
{
    // make sure the viewport matches the new window dimensions; note that width and 
    // height will be significantly larger than specified on retina displays.
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://learnopengl.com/Getting-started/Hello-Window&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 05 May 2021 01:37:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/notes/graphics/opengl/2021/05/05/Hello-Window/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/notes/graphics/opengl/2021/05/05/Hello-Window/</guid>
        
        <category>OpenGL</category>
        
        
        <category>notes</category>
        
        <category>graphics</category>
        
        <category>OpenGL</category>
        
      </item>
    
      <item>
        <title>Creating a window</title>
        <description>&lt;p&gt;&lt;img class=&quot;mid-img&quot; src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-04/Screenshot%202021-05-03%20234434.png&quot; /&gt;
&lt;img class=&quot;mid-img&quot; src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-04/Screenshot%202021-05-03%20234458.png&quot; /&gt;
&lt;img class=&quot;mid-img&quot; src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-04/Screenshot%202021-05-04%20015115.png&quot; /&gt;
&lt;img class=&quot;mid-img&quot; src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-04/Screenshot%202021-05-04%20014132.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://learnopengl.com/Getting-started/Creating-a-window&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 04 May 2021 01:20:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/notes/graphics/opengl/2021/05/04/Creating-a-window/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/notes/graphics/opengl/2021/05/04/Creating-a-window/</guid>
        
        <category>OpenGL</category>
        
        
        <category>notes</category>
        
        <category>graphics</category>
        
        <category>opengl</category>
        
      </item>
    
      <item>
        <title>Opengl</title>
        <description>&lt;p&gt;&lt;img class=&quot;mid-img&quot; src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-03/Screenshot%202021-05-03%20001642.png&quot; /&gt;
&lt;img class=&quot;mid-img&quot; src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-03/Screenshot%202021-05-03%20003257.png&quot; /&gt;
&lt;img class=&quot;mid-img&quot; src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-03/Screenshot%202021-05-03%20003027.png&quot; /&gt;
&lt;img class=&quot;mid-img&quot; src=&quot;/assets/img/post/notes/graphics/OpenGL/2021-05-03/Screenshot%202021-05-03%20003847.png&quot; /&gt;
&lt;a href=&quot;https://learnopengl.com/Getting-started/OpenGL&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 03 May 2021 00:40:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/notes/graphics/opengl/2021/05/03/OpenGL/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/notes/graphics/opengl/2021/05/03/OpenGL/</guid>
        
        <category>OpenGL</category>
        
        
        <category>notes</category>
        
        <category>graphics</category>
        
        <category>opengl</category>
        
      </item>
    
      <item>
        <title>I made a snake game</title>
        <description>&lt;p&gt;Last year, I made a game called snake game following youtube video tutorial.&lt;br /&gt;
It was not easy for me from the beginning but it quite helped me with understanding basic sutff about CSS and JS. 
\&lt;/p&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;
    &lt;canvas id=&quot;game_area&quot;&gt;&lt;/canvas&gt;&lt;br /&gt;
    &lt;button class=&quot;btn up&quot;&gt;UP&lt;/button&gt;&lt;br /&gt;
    &lt;button class=&quot;btn left&quot;&gt;LEFT&lt;/button&gt;
    &lt;button class=&quot;btn right&quot;&gt;RIGHT&lt;/button&gt;&lt;br /&gt;
    &lt;button class=&quot;btn down&quot;&gt;DOWN&lt;/button&gt;&lt;br /&gt;
    &lt;button id=&quot;start&quot;&gt;START&lt;/button&gt;&lt;br /&gt;
    &lt;span id=&quot;author&quot;&gt;Made by jeheecheon&lt;/span&gt;&lt;br /&gt;
&lt;/div&gt;

&lt;script&gt;
//////////////////////////////////////////////////
//////////////////////////////////////////////////
var canvas = document.getElementById(&quot;game_area&quot;);
var ctx = canvas.getContext(&quot;2d&quot;);
var startBtn = document.getElementById('start');
var direction = &quot; &quot;;
var bestScore = 0;
var score;
const width = 450;
const height = 350;
const snakeSize = 10;
//////////////////////////////////////////////////
//////////////////////////////////////////////////

(function() {
  upBtn = document.getElementsByClassName(&quot;btn&quot;);
  upBtn[0].onmousedown=upBtn[0].ontouchstart=function() {
    if (direction!=&quot;down&quot;)
      direction=&quot;up&quot;;
  };
  upBtn[1].onmousedown=upBtn[1].ontouchstart=function() {
    if (direction!=&quot;right&quot;)
      direction=&quot;left&quot;;
  };
  upBtn[2].onmousedown=upBtn[2].ontouchstart=function() {
    if (direction!=&quot;left&quot;)
      direction=&quot;right&quot;; 
  };
  upBtn[3].onmousedown=upBtn[3].ontouchstart=function() {
    if (direction!=&quot;up&quot;)
      direction=&quot;down&quot;;
  };
  
  window.onkeydown = function(event) {
    switch (event.keyCode) {
    case 37:  //left arrow key
    case 65:  //a key
      if (direction != &quot;rignt&quot;)
        direction = &quot;left&quot;;
      break;
    case 38:  //up arrow key
    case 87:  //w key
      if (direction != &quot;down&quot;)
        direction = &quot;up&quot;;
      break; 
    case 39:  //right arrow key
    case 68:  //d key
      if (direction != &quot;left&quot;)
        direction = &quot;right&quot;;
      break;
    case 40:  //left arrow key
    case 83:  //s key
      if (direction != &quot;up&quot;)
        direction = &quot;down&quot;;
      break;
    default:
      break;
    }
  }
  window.onload = function() {snakeGame.init();};
  startBtn.addEventListener(&quot;click&quot;, function() {snakeGame.start();});
}());

var snakeGame = (function() {
  var init = function() {
    canvas.width = width;
    canvas.height = height;
    areaClear();
  }
  
  var areaClear = function() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'lightgrey';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = 'black';
    ctx.strokeRect(0, 0, canvas.width, canvas.height);
  }
  
  var start = function() {
    startBtn.disabled = true;
    score = 0;
    direction = &quot;down&quot;;
    mySnake = new makeSnake(3);
    createFood();
    gameInterval = setInterval(updateGame, 100);
  }
  
  var stop = function() {
    clearInterval(gameInterval);
    bestScore = (score &gt; bestScore) ? score : bestScore;
    startBtn.disabled = false;
  }
  
  var makeSnake = function(tail_length) {
    this.snake = [];
    for (var i = tail_length; i &gt;= 0; i--)
      this.snake.push({x: i, y: 0})
          
    this.newPos = function() {
      posX = this.snake[0].x;
      posY = this.snake[0].y;
      switch (direction) {
      case &quot;left&quot;:
        posX--;
        break;
      case &quot;right&quot;:
        posX++;
        break;
      case &quot;up&quot;:
        posY--;
        break;
      case &quot;down&quot;:
        posY++;
        break;
      default:
        break;
      }
      if (checkCollision(posX, posY, this.snake))
        stop();
      this.snake.unshift({x: posX,y: posY});  
      if (isThereFood(posX, posY)) {
        score++;
        createFood();
      }
      else
        this.snake.pop();
    }

    this.display = function() {
      for (var i = 0; i &lt; this.snake.length; i++)
        draw.snakeBody(this.snake[i].x, this.snake[i].y)
    }
  }
  
  var draw = {
    snakeBody: function(x, y) {
      ctx.fillStyle = 'green';
      ctx.fillRect(x * snakeSize, y * snakeSize, snakeSize, snakeSize);
      ctx.strokeStyle = 'darkgreen';
      ctx.strokeRect(x * snakeSize, y * snakeSize, snakeSize, snakeSize);
    },
    food: function(x, y) {
      ctx.fillStyle='brown';
      ctx.fillRect(x * snakeSize,y * snakeSize, snakeSize, snakeSize);
      ctx.strokeStyle ='black';
      ctx.strokeRect(x * snakeSize, y * snakeSize, snakeSize, snakeSize);
    },
    scoreText: function(x, y, font, color) {
      text = &quot;BEST SCORE: &quot; + bestScore + &quot;   MY SCORE: &quot; + score;
      ctx.font = font;
      ctx.fillStyle = color;
      ctx.fillText(text, x, y);
    }
  }
  
  var checkCollision = function(x, y, arr) {
    if (x &lt; 0 || y &lt; 0 || x &gt;= width/10 || y &gt;= height/10)
      return true;
    for (i = 0; i &lt; arr.length; i++)
      if (x == arr[i].x &amp;&amp; y == arr[i].y) 
        return true;
    return false;
  }
    
  var createFood = function() {
    do {
      foodX=Math.round(Math.random()*(width/10));
      foodY=Math.round(Math.random()*(height/10));
    } while(checkCollision(foodX, foodY, mySnake.snake));
  }
  
  var isThereFood = function(headX, headY) {
    return headX == foodX &amp;&amp; headY == foodY;
  }
  
  var updateGame = function() {
    areaClear();
    mySnake.newPos();
    mySnake.display();
    draw.food(foodX, foodY);
    draw.scoreText(10, height - 10, &quot;15px Georgia&quot;, &quot;black&quot;);
  }
  
  return {init: init, start: start};
}());

&lt;/script&gt;

&lt;style&gt;
      #start {
        background-color: skyblue;
        color: white;
        border: none;
        margin: 20px 0px 0px 0px;
        width: 200px;
        height: 30px;
      }
      #start:hover {
        background-color: orange;
      }
      #start:disabled {
        background-color: grey;
      }
      #author {
        color: lightblue;
        text-shadow: 3px 1px blue;
        font: italic normal bold 30px/30px &quot;Helvetica&quot;;
      }
      #desc {
        font: normal normal bold 20px/20px &quot;Helvetica&quot;;
      }
      #blog {
        font: normal normal bold 15px/15px &quot;Helvetica&quot;;
      }
      .btn {
        background-color:skyblue;
        border:none;
        color:white;
        width:50px;
        height:35px;
        margin:5px 2px 0px 2px;
      }
      .btn:active {
        background-color:blue;
      }
&lt;/style&gt;

</description>
        <pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/daily-life/2021/01/20/daily-life/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/daily-life/2021/01/20/daily-life/</guid>
        
        
        <category>daily-life</category>
        
      </item>
    
      <item>
        <title>DIART#1</title>
        <description>&lt;p&gt;DIARY TEST&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/diary/2020/12/08/diary/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/diary/2020/12/08/diary/</guid>
        
        
        <category>diary</category>
        
      </item>
    
      <item>
        <title>DPI</title>
        <description>&lt;p&gt;Dots per inch (DPI)&lt;br /&gt;
In typography, the size of type is measured in units called points. One point equals 1/72 of an inch.
physical inches are not a useful measure, because there is no fixed relation between physical inches and pixels. Instead, fonts are measured in logical units. A 72-point font is defined to be one logical inch tall. Logical inches are then converted to pixels. or many years, Windows used the following conversion: One logical inch equals 96 pixels.
12 points = 12/72 logical inch = 1/6 logical inch = 96/6 pixels = 16 pixels
This scaling factor is described as 96 dots per inch (DPI).&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;The following illustration shows a 72-point font. The solid lines show a 1” tall bounding box around the text. The dashed line is called the baseline. Most of the characters in a font rest on the baseline. The height of the font includes the portion above the baseline (the ascent) and the portion below the baseline (the descent). In the font shown here, the ascent is 56 points and the descent is 16 points. &lt;br /&gt;
&lt;img src=&quot;https://docs.microsoft.com/en-us/windows/win32/learnwin32/images/graphics11.png&quot; alt=&quot;1 inch&quot; class=&quot;mid-img&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/learnwin32/dpi-and-device-independent-pixels&quot;&gt;출처: Microsoft&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Sep 2020 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/notes/graphics/win32/2020/09/17/win32/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/notes/graphics/win32/2020/09/17/win32/</guid>
        
        <category>notes</category>
        
        <category>win32</category>
        
        <category>DPI</category>
        
        <category>graphic</category>
        
        
        <category>notes</category>
        
        <category>graphics</category>
        
        <category>win32</category>
        
      </item>
    
      <item>
        <title>win32 의 COM Reference Counting</title>
        <description>&lt;p&gt;&lt;br /&gt;
공부하면서 중요한 부분만 발췌했기 때문에 문맥이 매끄럽지 못하고 부정확한 부분이 있음.&lt;br /&gt;
&lt;br /&gt;
COM Interfaces 에 한가지 중요한 규칙이 있는데 이는 IUnknown 이라는 인터페이스를 반드시 상속받는 다는 것이다.&lt;br /&gt;
IUnknown 는 밑에 언급되는 세 가지 Methods를 가지고 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;QueryInterface&lt;/li&gt;
  &lt;li&gt;AddRef&lt;/li&gt;
  &lt;li&gt;Release&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;QueryInterfaec는 프로그램이 객체의 capabilities를 query 할 수 있게 해준다.&lt;br /&gt;
AddRef 와 Release 는 object의 라이프 타임을 결정하게 해주는 중요한 녀석이다.&lt;br /&gt;
&lt;br /&gt;
모든 COM object는 내부 카운트를 유지한다. 이것을 &lt;strong&gt;reference count&lt;/strong&gt;라고 부르고 이는 해당 객체를 참고하는 녀석이 몇 개나 활성화 되어있는가를 보여주는 거를 일겉는다.&lt;br /&gt;
그 숫자가 0에 달했을 시 그 object는 스스로 삭제시킨다. 중요한 부분은 프로그램이 명시적으로 삭제하는 것이 아니라 객체 스스로 없어진다는 것이다.&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;https://docs.microsoft.com/en-us/windows/win32/learnwin32/images/com04.png&quot; alt=&quot;&quot; class=&quot;mid-img&quot; /&gt;&lt;br /&gt;
프로그램이 처음 만들어지면 reference count는 1이 된다.&lt;br /&gt;
그리고 해당 프로그램의 사용을 마친 후 반드시 release를 통해 reference count 를 1감소 시켜야 한다. 이를 통해 
객체의 포인터를 무효화(정지) 를 시킬 수 있다.&lt;br /&gt;
만약 객체의 주소를 다른 포인터 변수에 저장할 일이 있을 때는 AddRef 함수를 통해 reference count를 1 증가시켜줘야만 한다.&lt;br /&gt;
다음 사진과 같이&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;https://docs.microsoft.com/en-us/windows/win32/learnwin32/images/com05.png&quot; alt=&quot;&quot; class=&quot;mid-img&quot; /&gt;&lt;br /&gt;
만약 두 개의 포인터 변수(p,q)가 한 개의 주소를 갖고 있고 AddRef를 하지 않았을 땐 ref count가 1일 것이다. 이때 p가 일을 마치고 release를 하면 값이 0이 되고 q는 무효한 변수로 남게된다. 때문에 변수값을 다른 변수에 저장시 AddRef 호출은 반드시 필요하다.&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
그런데, 객체 주소를 다른 포인터 변수에 저장하는 이유는 무엇일까? 두 가지 이유가 있다.&lt;br /&gt;
첫 번째, structur 나 list 에 저장하기를 원할 때.
두 번째, 포인터 current scope 을 넘어서 사용하고 싶을 때. - [전역변수]&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;전역 후에 오랜만에 win32를 다시 훑는 중인데 확실히 원어로 접하는게 내용수준도 깊고 좋은 것 같다. 다만 읽는데 아직 좀 버거워서 힘들지만 ㅋㅋ 영어 공부도 병행하면서 틈틈히 전공지식도 늘려가는게 좋을 것 같다.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/learnwin32/managing-the-lifetime-of-an-object&quot;&gt;출처: Microsoft&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Sep 2020 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/notes/graphics/win32/2020/09/13/win32/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/notes/graphics/win32/2020/09/13/win32/</guid>
        
        <category>notes</category>
        
        <category>win32</category>
        
        <category>CPP</category>
        
        <category>COM</category>
        
        
        <category>notes</category>
        
        <category>graphics</category>
        
        <category>win32</category>
        
      </item>
    
      <item>
        <title>jekyll 개인 블로그 개설!</title>
        <description>&lt;h1 id=&quot;jekyll-블로그-개설&quot;&gt;&lt;center&gt;jekyll 블로그 개설!&lt;/center&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/post/daily-life/2020-08-29/ant.gif&quot; alt=&quot;춤추는 엔트 사진&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;jekyll(static site generator)&lt;/strong&gt; 을 이용해서 블로그를 새로 만들어 이주했습니다.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/post/daily-life/2020-08-29/blog-code.png&quot; alt=&quot;블로그 코드 스크린샷&quot; width=&quot;100%&quot; /&gt;  &lt;br /&gt;
게시물 주제는 앞으로도 마찬가지로 &lt;strong&gt;프로그래밍 공부 기록&lt;/strong&gt; 및 &lt;strong&gt;정보 공유&lt;/strong&gt; 위주 포스팅이 될 것 같습니다.&lt;br /&gt;
&lt;a href=&quot;https://blog.naver.com/0511cjh&quot;&gt;이주 전 네이버 블로그&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 29 Aug 2020 00:00:00 +0000</pubDate>
        <link>https://jeheecheon.github.io/daily-life/2020/08/29/daily-life/</link>
        <guid isPermaLink="true">https://jeheecheon.github.io/daily-life/2020/08/29/daily-life/</guid>
        
        <category>jekyll</category>
        
        <category>blog</category>
        
        <category>블로그</category>
        
        <category>개설</category>
        
        
        <category>daily-life</category>
        
      </item>
    
  </channel>
</rss>